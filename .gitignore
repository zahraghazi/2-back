import pygame as pg
import numpy as np
import random 
import math
import os
import pandas as pd
from xlsxwriter import Workbook

# Initialize pygame
pg.init()

# Set up display
DISPLAY_WIDTH, DISPLAY_HEIGHT = 1400, 720
screen = pg.display.set_mode((DISPLAY_WIDTH, DISPLAY_HEIGHT))

# Define colors
BLACK = (0, 0, 0)
WHITE = (255, 255, 255)

# Set the path to your music file
music_file_path = r"C:\Users\technotak\Desktop\Sonata.mp3"

# Load sound file
my_sound = pg.mixer.Sound(music_file_path)

# Define background color
BG_COLOR = pg.Color(0, 0, 0)

# Function to display a black screen until mouse click
def black_screen(screen):
    screen.fill(BG_COLOR)
    pg.display.flip()
    ready = False
    while not ready:
        for event in pg.event.get():
            if event.type == pg.MOUSEBUTTONDOWN or event.type == pg.KEYDOWN:
                ready = True

# Function to display "READY!" message until mouse click
def getting_ready(screen):
    font = pg.font.Font(None, 100)
    txt = font.render('2-back task', True, (150, 150, 150))
    screen_rect = screen.get_rect()
    screen.fill(BG_COLOR)
    screen.blit(txt, txt.get_rect(center=screen_rect.center))
    pg.display.flip()
    ready = False
    while not ready:
        for event in pg.event.get():
            if event.type == pg.MOUSEBUTTONDOWN or event.type == pg.KEYDOWN:
                ready = True

# Function to display "2-back" message
def nback_ready(screen):
    font = pg.font.Font(None, 200)
    font = pg.font.SysFont('Arial', 50)
    color = (100, 100, 100)
    txt = font.render('digit, shape, color, face', True, color)
    screen_rect = screen.get_rect()
    screen.fill(BG_COLOR)
    screen.blit(txt, txt.get_rect(center=screen_rect.center))
    pg.display.flip()
    pg.time.delay(3500)

# Function to display a number and wait for a delay
def display_number(screen, number):
    font = pg.font.Font(None, 300)
    txt = font.render(str(number), True, (255, 255, 255))
    screen_rect = screen.get_rect()
    screen.fill(BG_COLOR)
    screen.blit(txt, txt.get_rect(center=screen_rect.center))
    pg.display.flip()
    pg.time.delay(1200)
    screen.fill(BG_COLOR)
    pg.display.flip()
    pg.time.delay(300)

# Function to run the 2-back digit task
def run_digit_task(screen):
    displayed_numbers = []
    targeted_click_number = []
    real_click_number = []

    start_time = pg.time.get_ticks()
    crash = False

    while not crash:
        new_number = np.random.randint(low=3, high=8)
        displayed_numbers.append(new_number)
        real_click_number.append(0)

        if len(displayed_numbers) <= 2:
            targeted_click_number.append(0)
        else:
            targeted_click_number.append(1 if displayed_numbers[-1] == displayed_numbers[-3] else 0)

        for event in pg.event.get():
            if event.type == pg.KEYDOWN:
                if event.key == pg.K_ESCAPE:
                    crash = True
                if event.key == pg.K_a:
                    real_click_number[-2] = 1
            elif event.type == pg.QUIT:
                crash = True

        current_time = pg.time.get_ticks()
        elapsed_time = current_time - start_time
        if elapsed_time >= 40000:  # 40 seconds
            crash = True

        display_number(screen, new_number)

    return displayed_numbers, targeted_click_number, real_click_number

# Center position
CENTER = (DISPLAY_WIDTH // 2, DISPLAY_HEIGHT // 2)

# Shape drawing functions
def draw_rectangle(surface, color, position, size):
    x, y = position
    return pg.draw.rect(surface, color, (x - size, y - size // 2, size * 2, size))

def draw_circle(surface, color, position, size):
    return pg.draw.circle(surface, color, position, size)

def draw_4_sided_star(surface, color, position, size):
    x, y = position
    points = [(x, y - size), (x + size // 2, y), (x, y + size), (x - size // 2, y)]
    return pg.draw.polygon(surface, color, points)

def draw_triangle(surface, color, position, size):
    x, y = position
    points = [(x, y - size), (x + size, y + size), (x - size, y + size)]
    return pg.draw.polygon(surface, color, points)

def draw_oval(surface, color, position, size):
    x, y = position
    return pg.draw.ellipse(surface, color, (x - size, y - size // 2, size * 2, size))

def draw_square(surface, color, position, size):
    x, y = position
    return pg.draw.rect(surface, color, (x - size // 2, y - size // 2, size, size))

def draw_pentagon(surface, color, position, size):
    x, y = position
    points = [(x + size * math.cos(math.radians(72 * i - 90)), y + size * math.sin(math.radians(72 * i - 90))) for i in range(5)]
    return pg.draw.polygon(surface, color, points)

def draw_6_sided_star(surface, color, position, size):
    x, y = position
    outer_points = [(x + size * math.cos(math.radians(60 * i - 90)), y + size * math.sin(math.radians(60 * i - 90))) for i in range(6)]
    inner_points = [(x + (size / 2) * math.cos(math.radians(60 * i - 60)), y + (size / 2) * math.sin(math.radians(60 * i - 60))) for i in range(6)]
    points = [val for pair in zip(outer_points, inner_points) for val in pair]
    return pg.draw.polygon(surface, color, points)

# Define the shapes
shapes = [
    ('rectangle', draw_rectangle),
    ('circle', draw_circle),
    ('4_sided_star', draw_4_sided_star),
    ('triangle', draw_triangle),
    ('oval', draw_oval),
    ('square', draw_square),
    ('pentagon', draw_pentagon),
    ('6_sided_star', draw_6_sided_star)
]

# Function to run the 2-back shape task
def run_shape_task(screen):
    displayed_shapes = []
    targeted_click_shape = []
    real_click_shape = []

    start_time = pg.time.get_ticks()
    crash = False

    while not crash:
        new_shape_index = random.randint(0, len(shapes) - 1)
        displayed_shapes.append(new_shape_index)
        real_click_shape.append(0)

        if len(displayed_shapes) <= 2:
            targeted_click_shape.append(0)
        else:
            targeted_click_shape.append(1 if displayed_shapes[-1] == displayed_shapes[-3] else 0)

        for event in pg.event.get():
            if event.type == pg.KEYDOWN:
                if event.key == pg.K_ESCAPE:
                    crash = True
                if event.key == pg.K_a:
                    real_click_shape[-2] = 1
            elif event.type == pg.QUIT:
                crash = True

        current_time = pg.time.get_ticks()
        elapsed_time = current_time - start_time
        if elapsed_time >= 40000:  # 40 seconds
            crash = True

        screen.fill(BLACK)
        shape_name, shape_func = shapes[new_shape_index]
        shape_func(screen, WHITE, CENTER, 100)
        pg.display.flip()
        pg.time.delay(1200)
        screen.fill(BLACK)
        pg.display.flip()
        pg.time.delay(300)

    return displayed_shapes, targeted_click_shape, real_click_shape

# Function to run the 2-back color task
def run_color_task(screen):
    displayed_colors = []
    targeted_click_color = []
    real_click_color = []

    start_time = pg.time.get_ticks()
    crash = False

    colors = [WHITE, (128, 128, 128), (0, 255, 0), (0, 0, 255)]
    color_names = ['white', 'gray', 'red', 'green', 'blue']

    while not crash:
        new_color_index = random.randint(0, len(colors) - 1)
        displayed_colors.append(new_color_index)
        real_click_color.append(0)

        if len(displayed_colors) <= 2:
            targeted_click_color.append(0)
        else:
            targeted_click_color.append(1 if displayed_colors[-1] == displayed_colors[-3] else 0)

        for event in pg.event.get():
            if event.type == pg.KEYDOWN:
                if event.key == pg.K_ESCAPE:
                    crash = True
                if event.key == pg.K_a:
                    real_click_color[-2] = 1
            elif event.type == pg.QUIT:
                crash = True

        current_time = pg.time.get_ticks()
        elapsed_time = current_time - start_time
        if elapsed_time >= 40000:  # 40 seconds
            crash = True

        screen.fill(colors[new_color_index])
        pg.display.flip()
        pg.time.delay(1200)
        screen.fill(BLACK)
        pg.display.flip()
        pg.time.delay(300)

    return displayed_colors, targeted_click_color, real_click_color

# Function to display face images
def display_face(screen, face_image):
    screen.fill(BG_COLOR)
    screen.blit(face_image, face_image.get_rect(center=(DISPLAY_WIDTH // 2, DISPLAY_HEIGHT // 2)))
    pg.display.flip()
    pg.time.delay(1200)
    screen.fill(BG_COLOR)
    pg.display.flip()
    pg.time.delay(300)

# Function to run the 2-back face task
def run_face_task(screen, face_folder):
    displayed_faces = []
    targeted_click_face = []
    real_click_face = []

    start_time = pg.time.get_ticks()
    crash = False

    face_filenames = ['face3.jpg', 'face4.jpg', 'face5.jpg', 'face6.jpg', 'face7.jpg', 'face8.jpg']

    # Ensure the path to the images directory is correct
    images_dir = 'faces'
    faces = [pg.image.load(os.path.join(r"F:\neurosciense\interdiscipnilary\mentor\team35", filename)) for filename in face_filenames]

    # Scale faces to a standard size
    FACE_SIZE = (200, 200)
    faces = [pg.transform.scale(face, FACE_SIZE) for face in faces]

    while not crash:
        new_face_index = random.randint(0, len(faces) - 1)
        displayed_faces.append(new_face_index)
        real_click_face.append(0)

        if len(displayed_faces) <= 2:
            targeted_click_face.append(0)
        else:
            targeted_click_face.append(1 if displayed_faces[-1] == displayed_faces[-3] else 0)

        for event in pg.event.get():
            if event.type == pg.KEYDOWN:
                if event.key == pg.K_ESCAPE:
                    crash = True
                if event.key == pg.K_a:
                    real_click_face[-2] = 1
            elif event.type == pg.QUIT:
                crash = True

        current_time = pg.time.get_ticks()
        elapsed_time = current_time - start_time
        if elapsed_time >= 40000:  # 40 seconds
            crash = True

        display_face(screen, faces[new_face_index])

    return displayed_faces, targeted_click_face, real_click_face

def export_results_to_excel(filename, digit_results_before, shape_results_before, color_results_before, face_results_before,
                            digit_results_after, shape_results_after, color_results_after, face_results_after):
    # Create a Pandas Excel writer
    writer = pd.ExcelWriter(filename, engine='xlsxwriter')

    # Helper function to save results to Excel
    def save_task_results(task_name, results_before, results_after):
        before_df = pd.DataFrame({
            f'{task_name}_displayed': results_before[0],
            f'{task_name}_targeted': results_before[1],
            f'{task_name}_real': results_before[2]
        })
        after_df = pd.DataFrame({
            f'{task_name}_displayed': results_after[0],
            f'{task_name}_targeted': results_after[1],
            f'{task_name}_real': results_after[2]
        })
        before_df.to_excel(writer, sheet_name=f'{task_name}_before', index=False)
        after_df.to_excel(writer, sheet_name=f'{task_name}_after', index=False)

    # Save each task's results
    save_task_results('digit', digit_results_before, digit_results_after)
    save_task_results('shape', shape_results_before, shape_results_after)
    save_task_results('color', color_results_before, color_results_after)
    save_task_results('face', face_results_before, face_results_after)

    # Save the Excel file
    writer._save()

def main():
    # Wait for initial click to start
    black_screen(screen)
    getting_ready(screen)
    nback_ready(screen)
    
    # Define the path to the face image folder
    face_folder = r'F:\neurosciense\interdisciplinary\mentor\team35'

    # Run each task in sequence
    digit_results_before = run_digit_task(screen)
    shape_results_before = run_shape_task(screen)
    color_results_before = run_color_task(screen)
    face_results_before = run_face_task(screen, face_folder)
    
    pg.mixer.Sound.play(my_sound)  # Play the sound after initial tasks
    black_screen(screen)  # Wait for initial click to start second part
    getting_ready(screen)
    nback_ready(screen)
    
    digit_results_after = run_digit_task(screen)
    shape_results_after = run_shape_task(screen)
    color_results_after = run_color_task(screen)
    face_results_after = run_face_task(screen, face_folder)

    export_results_to_excel(r'F:\neurosciense\interdiscipnilary\mentor\team35\n-back_task_results.xlsx', digit_results_before, shape_results_before, color_results_before, face_results_before,
                            digit_results_after, shape_results_after, color_results_after, face_results_after)

    pg.quit()

if __name__ == "__main__":
    main()
